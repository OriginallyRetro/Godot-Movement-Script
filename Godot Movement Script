extends CharacterBody3D

const AK_ROTATION_SPEED: float = 3.0
const CAMERA_ROTATION_SPEED: float = 1.5
const FALL_DAMAGE_THRESHOLD: float = 10.0
const NORMAL_HEIGHT: float = 1.0

@export_subgroup("SLIDING")
@export var SLIDE_HEIGHT: float = 0.3
@export var SLIDE_SPEED: float = 30.0
@export var SLIDE_FRICTION: float = 0.5
@export var SLIDE_DURATION: float = 1.0
@export var SLIDE_TRANSITION_SPEED: float = 7.5  # Speed at which the slide transition occurs

@export_subgroup("CROUCHING")
@export var CROUCH_SPEED: float = 3.5
@export var CROUCH_HEIGHT: float = 0.5
@export var CROUCH_TIME_ACUMMALTED: float = 0.0
@export var CROUCH_TRANSITION_SPEED: float = 5.0  # Speed at which the crouch transition occurs

@export_subgroup("MOVEMENT")
@export var DEFAULT_SPEED: float = 5.5
@export var OLD_VELOCITY: float = 0.0

@export_subgroup("SPRINTING")
@export var SPRINT_MULTIPLIER: float = 2.5
@export var SPRINT_TIME_ACUMMALTED: float = 0.0

@export_subgroup("JUMPING")
@export var JUMP_VELOCITY: float = 4.0

@export_subgroup("EXTRA")
@export var SLIDING_FOV: float = 90.0
@export var CROUCH_FOV: float = 70.0
@export var NORMAL_FOV: float = 80.0  # Normal Field of View
@export var SPRINT_FOV: float = 105.0  # Sprinting Field of View
@export var FOV_TRANSITION_SPEED: float = 5.0  # Speed at which the FOV transition occurs
@export var HEALING_COLOR = Color("#4dff6e")

var gravity = ProjectSettings.get_setting("physics/3d/default_gravity")
@onready var NECK := $Neck
@onready var CAMERA := $Neck/Camera3D
@onready var COLLISION_SHAPE = $CollisionShape3D
@onready var HURT_OVERLAY = $HurtOverlay
@onready var ANIM_PLAY = $Neck/Camera3D/AnimationPlayer
@onready var HEALTH_BAR = $HealthBar
@onready var HEALTH_BAR_BG = $HealthBarBG
@onready var MANA_BAR = $ManaBar
@onready var MANA_BAR_BG = $ManaBarBG
@onready var HUNGER_BAR = $HungerBar
@onready var HUNGER_BAR_BG = $HungerBarBG
@onready var SPRINT_HUNGER_TIMER = $"../SprintHungerTimer"
@onready var CROUCH_HUNGER_TIMER = $"../CrouchHungerTimer"
@onready var HEALTH_REGEN_TIMER = $"../HealthRegenTimer"


var IS_CROUCHING = false
var IS_SLIDING = false
var SLIDE_TIMER = 0.0
var SLIDE_DIRECTION: Vector3 = Vector3.ZERO
var HURT_TWEEN: Tween
var MANA_TWEEN: Tween
var HUNGER_TWEEN: Tween

func _ready():
	HEALTH_BAR.value = HEALTH_BAR_BG.value
	MANA_BAR.value = MANA_BAR_BG.value
	HUNGER_BAR.value = HUNGER_BAR_BG.value

	SPRINT_HUNGER_TIMER.timeout.connect(_on_sprint_hunger_timeout)
	CROUCH_HUNGER_TIMER.timeout.connect(_on_crouch_hunger_timeout)
	HEALTH_REGEN_TIMER.timeout.connect(_on_health_regen_timeout)
	HEALTH_REGEN_TIMER.start(15.0)  # Start the timer with a 15-second interval	

func _unhandled_input(event: InputEvent) -> void:
	if event is InputEventMouseButton:
		Input.set_mouse_mode(Input.MOUSE_MODE_CAPTURED)
		
	if event.is_action_pressed("ui_cancel"):
		get_tree().quit()
		
	if Input.get_mouse_mode() == Input.MOUSE_MODE_CAPTURED:
		if event is InputEventMouseMotion:
			NECK.rotate_y(-event.relative.x * 0.01)
			CAMERA.rotate_x(-event.relative.y * 0.01)
			CAMERA.rotation.x = clamp(CAMERA.rotation.x, deg_to_rad(-30), deg_to_rad(60))
	
func _physics_process(delta: float) -> void:
	# Add gravity
	if not is_on_floor():
		velocity.y -= gravity * delta
		
	# Handle arrow keys
	if Input.is_action_pressed("ui_left"):
		NECK.rotate_y(AK_ROTATION_SPEED * delta)
	
	if Input.is_action_pressed("ui_right"):
		NECK.rotate_y(-AK_ROTATION_SPEED * delta)

	if Input.is_action_pressed("ui_up"):
		CAMERA.rotate_x(AK_ROTATION_SPEED * delta)
	
	if Input.is_action_pressed("ui_down"):
		CAMERA.rotate_x(-AK_ROTATION_SPEED * delta)
	
	# Handle Jump
	if Input.is_action_just_pressed("ui_accept") and is_on_floor():
		velocity.y = JUMP_VELOCITY
	
	# Sprinting logic
	var IS_SPRINTING = Input.is_action_pressed("Shift") 
	if IS_SPRINTING:
		SPRINT_TIME_ACUMMALTED += delta
		CAMERA.fov = lerp(CAMERA.fov, SPRINT_FOV, FOV_TRANSITION_SPEED * delta)
		if SPRINT_TIME_ACUMMALTED >= 15.0:
			_on_sprint_hunger_timeout()
			SPRINT_TIME_ACUMMALTED = 0.0
			CAMERA.fov = lerp(CAMERA.fov, SPRINT_FOV, FOV_TRANSITION_SPEED * delta)
	else:
		SPRINT_TIME_ACUMMALTED = 0.0
		CAMERA.fov = lerp(CAMERA.fov, NORMAL_FOV, FOV_TRANSITION_SPEED * delta)
	
	# Crouching logic
	IS_CROUCHING = Input.is_action_pressed("Crouch") and is_on_floor()
	
	# Smooth transition for crouch height
	if IS_CROUCHING:
		scale.y = lerp(scale.y, CROUCH_HEIGHT, CROUCH_TRANSITION_SPEED * delta)
		CAMERA.fov = lerp(CAMERA.fov, CROUCH_FOV, FOV_TRANSITION_SPEED * delta)
		CROUCH_TIME_ACUMMALTED += delta
		if CROUCH_TIME_ACUMMALTED >= 5.0:
			_on_crouch_hunger_timeout()
			CROUCH_TIME_ACUMMALTED = 0.0
	else:
		CAMERA.fov = lerp(CAMERA.fov, NORMAL_FOV, FOV_TRANSITION_SPEED * delta)
		scale.y = lerp(scale.y, NORMAL_HEIGHT, CROUCH_TRANSITION_SPEED * delta)
		CROUCH_TIME_ACUMMALTED = 0.0
	
	# Sliding logic
	var SHOULD_SLIDE = Input.is_action_pressed("Slide") and is_on_floor()
	var INPUT_DIRECTION := Input.get_vector("Left", "Right", "Forward", "Backward")
	var DIRECTION = (NECK.transform.basis * Vector3(INPUT_DIRECTION.x, 0, INPUT_DIRECTION.y)).normalized()
	
	if SHOULD_SLIDE and not IS_SLIDING:
		hunger_mechanic(.2)
		IS_SLIDING = true
		SLIDE_TIMER = SLIDE_DURATION
		SLIDE_DIRECTION = DIRECTION
	
	if IS_SLIDING:
		CAMERA.fov = lerp(CAMERA.fov, SLIDING_FOV, FOV_TRANSITION_SPEED * delta)
		if Input.is_action_pressed("ui_accept"):
			IS_SLIDING = false
			SLIDE_TIMER = 0.0
			
		elif SLIDE_TIMER > 0:
			SLIDE_TIMER -= delta
			var time_fraction = max(SLIDE_TIMER / SLIDE_DURATION, 0)
			var CURRENT_SLIDE_SPEED = lerp(SLIDE_SPEED * 0.5, SLIDE_SPEED, time_fraction)
			scale.y = lerp(SLIDE_HEIGHT, NORMAL_HEIGHT, time_fraction)
			velocity.x = SLIDE_DIRECTION.x * CURRENT_SLIDE_SPEED
			velocity.z = SLIDE_DIRECTION.z * CURRENT_SLIDE_SPEED
			velocity.x *= (1 - SLIDE_FRICTION)
			velocity.z *= (1 - SLIDE_FRICTION)
	else:
		CAMERA.fov = lerp(CAMERA.fov, NORMAL_FOV, FOV_TRANSITION_SPEED * delta)
		if DIRECTION:
			if IS_CROUCHING:
				DEFAULT_SPEED = CROUCH_SPEED
			else:
				DEFAULT_SPEED = 5.0
			if IS_SPRINTING:
				DEFAULT_SPEED *= SPRINT_MULTIPLIER
			else:
				DEFAULT_SPEED = 5.0

			velocity.x = DIRECTION.x * DEFAULT_SPEED
			velocity.z = DIRECTION.z * DEFAULT_SPEED
		else:
			velocity.x = move_toward(velocity.x, 0, DEFAULT_SPEED)
			velocity.z = move_toward(velocity.z, 0, DEFAULT_SPEED)
			
	CAMERA.rotation.x = clamp(CAMERA.rotation.x, deg_to_rad(-40), deg_to_rad(60))
	move_and_slide()
	
	if OLD_VELOCITY < 0:
		var DIFFERENCE = velocity.y - OLD_VELOCITY
		if DIFFERENCE > FALL_DAMAGE_THRESHOLD:
			hurt(DIFFERENCE - FALL_DAMAGE_THRESHOLD)		
	OLD_VELOCITY = velocity.y
	
func _handle_cameras_rotation(_delta: float) -> void:
	CAMERA.rotation.x = clamp(CAMERA.rotation.x, deg_to_rad(-40), deg_to_rad(60))

func hurt(DAMAGE: float):
	HEALTH_BAR.value -= DAMAGE
	HURT_OVERLAY.modulate = Color.WHITE
	if HURT_TWEEN:
		HURT_TWEEN.kill()
	HURT_TWEEN = create_tween()
	HURT_TWEEN.parallel().tween_property(HURT_OVERLAY, "modulate", Color.TRANSPARENT, 3)
	
	HURT_TWEEN.set_ease(Tween.EASE_IN).set_trans(Tween.TRANS_CUBIC)
	HURT_TWEEN.parallel().tween_property(HEALTH_BAR_BG, "value", HEALTH_BAR.value, 0.6)

func _on_sprint_hunger_timeout():
	hunger_mechanic(3) 

func _on_crouch_hunger_timeout():
	hunger_mechanic(1.5)

func mana_mechanic(MANA_USAGE: float):
	MANA_BAR.value -= MANA_USAGE
	MANA_TWEEN = create_tween()
	MANA_TWEEN.tween_property(MANA_BAR_BG, "value", MANA_BAR.value, 1)
	MANA_TWEEN.set_ease(Tween.EASE_IN).set_trans(Tween.TRANS_CUBIC)
	
func hunger_mechanic(hunger_usage: float):
	HUNGER_BAR.value -= hunger_usage
	HUNGER_TWEEN = create_tween()
	HUNGER_TWEEN.tween_property(HUNGER_BAR_BG, "value", HUNGER_BAR.value, 3)
	HUNGER_TWEEN.set_ease(Tween.EASE_IN).set_trans(Tween.TRANS_CUBIC)
	
# Health regeneration logic
func _on_health_regen_timeout():
	if HEALTH_BAR.value < HEALTH_BAR.max_value:
		var previous_value = HEALTH_BAR.value
		HEALTH_BAR.value += 10
		HEALTH_BAR.value = clamp(HEALTH_BAR.value, 0, HEALTH_BAR.max_value)

		# Create a tween for the healing effect
		if HURT_TWEEN:
			HURT_TWEEN.kill()  # Kill any existing tween to avoid conflict
		HURT_TWEEN = create_tween()

		# Tween the health bar background value to match the new health value
		HURT_TWEEN.tween_property(HEALTH_BAR_BG, "value", HEALTH_BAR.value, 0.6)
		HURT_TWEEN.set_ease(Tween.EASE_IN).set_trans(Tween.TRANS_CUBIC)

		# Create a second tween to turn the health bar green during healing
		var bar_tween = create_tween()
		bar_tween.tween_property(HEALTH_BAR, "modulate", HEALING_COLOR, 0.3)
		# Delay for the second part of the bar color reset effect
		bar_tween.tween_property(HEALTH_BAR, "modulate", Color.WHITE, 0.3).set_delay(0.3)
